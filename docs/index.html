<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symmetry Group Classification</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .upload-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #667eea;
        }

        .upload-section h2 {
            color: #333;
            margin-bottom: 15px;
        }

        .file-input-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        input[type="file"] {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .console-section {
            margin-top: 30px;
        }

        .console-section h2 {
            color: #333;
            margin-bottom: 15px;
        }

        .console {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            min-height: 300px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
        }

        .console .log {
            color: #d4d4d4;
            margin-bottom: 5px;
        }

        .console .success {
            color: #4ec9b0;
        }

        .console .error {
            color: #f48771;
        }

        .console .info {
            color: #569cd6;
        }

        .console .warning {
            color: #dcdcaa;
        }

        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }

        .status.loading {
            background: #fff3cd;
            color: #856404;
            display: block;
        }

        .status.ready {
            background: #d4edda;
            color: #155724;
            display: block;
        }

        .clear-btn {
            margin-top: 10px;
            padding: 8px 20px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .clear-btn:hover {
            background: #5a6268;
        }

        .file-info {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ Symmetry Group Classification</h1>
            <p>Determines the symmetry group of atoms in a cell</p>
        </div>

        <div class="content">
            <div id="status" class="status loading">
                ‚è≥ Initializing Python environment...
            </div>

            <div class="upload-section">
                <h2>üì§ Upload Data File</h2>
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" accept=".txt,.csv,.json,.xyz" disabled>
                    <button class="btn btn-primary" id="uploadBtn" disabled>Process File</button>
                </div>
                <div id="fileInfo" class="file-info" style="display: none;"></div>
            </div>

            <div class="console-section">
                <h2>üíª Console Output</h2>
                <div id="console" class="console">
<span class="info">Welcome to Symmetry Group Classification!</span>
<span class="log">Waiting for Python environment to initialize...</span>
                </div>
                <button class="clear-btn" id="clearBtn">Clear Console</button>
            </div>
        </div>
    </div>

    <script>
        let pyodide;
        let fileContent = null;
        let fileName = null;

        const consoleElement = document.getElementById('console');
        const statusElement = document.getElementById('status');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const clearBtn = document.getElementById('clearBtn');
        const fileInfo = document.getElementById('fileInfo');

        // Console logging functions
        function logToConsole(message, type = 'log') {
            const line = document.createElement('span');
            line.className = type;
            line.textContent = message;
            consoleElement.appendChild(line);
            consoleElement.appendChild(document.createTextNode('\n'));
            consoleElement.scrollTop = consoleElement.scrollHeight;
        }

        function clearConsole() {
            consoleElement.innerHTML = '<span class="info">Console cleared.</span>\n';
        }

        // Initialize Pyodide
        async function initPyodide() {
            try {
                logToConsole('Loading Python environment (Pyodide)...', 'info');
                pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
                });
                
                logToConsole('Python environment loaded successfully!', 'success');
                logToConsole('Installing required packages...', 'info');
                
                // Install numpy for scientific computing
                await pyodide.loadPackage(['numpy', 'micropip']);
                
                logToConsole('Packages installed successfully!', 'success');
                
                // Define the Python symmetry group classification code
                await pyodide.runPythonAsync(`
import numpy as np
import json
from io import StringIO

def classify_symmetry_group(data):
    """
    Classify the symmetry group of atoms in a cell.
    
    Parameters:
    -----------
    data : str
        Input data containing atomic positions
        
    Returns:
    --------
    dict : Results of symmetry analysis
    """
    results = {
        'status': 'success',
        'message': 'Symmetry analysis completed',
        'data': {}
    }
    
    try:
        # Parse the input data
        lines = data.strip().split('\\n')
        
        # Try to detect the file format
        if data.strip().startswith('{'):
            # JSON format
            parsed = json.loads(data)
            if 'atoms' in parsed:
                atoms = np.array(parsed['atoms'])
            else:
                atoms = np.array(list(parsed.values()))
        else:
            # Try to parse as CSV or space-delimited
            atoms = []
            for line in lines:
                if line.strip() and not line.startswith('#'):
                    parts = line.replace(',', ' ').split()
                    if len(parts) >= 3:
                        try:
                            coords = [float(parts[i]) for i in range(min(3, len(parts)))]
                            atoms.append(coords)
                        except ValueError:
                            continue
            atoms = np.array(atoms)
        
        if len(atoms) == 0:
            return {
                'status': 'error',
                'message': 'No valid atomic coordinates found in input data'
            }
        
        # Basic symmetry analysis
        results['data']['num_atoms'] = len(atoms)
        results['data']['coordinates'] = atoms.tolist()
        
        # Calculate center of mass
        center = np.mean(atoms, axis=0)
        results['data']['center_of_mass'] = center.tolist()
        
        # Translate to center
        centered_atoms = atoms - center
        
        # Check for inversion symmetry
        has_inversion = check_inversion_symmetry(centered_atoms)
        results['data']['has_inversion_symmetry'] = has_inversion
        
        # Check for mirror planes
        mirror_planes = check_mirror_planes(centered_atoms)
        results['data']['mirror_planes'] = mirror_planes
        
        # Calculate distances from center
        distances = np.linalg.norm(centered_atoms, axis=1)
        results['data']['distances_from_center'] = distances.tolist()
        
        # Check for rotational symmetry
        rotation_symmetry = check_rotation_symmetry(centered_atoms)
        results['data']['rotation_symmetry'] = rotation_symmetry
        
        # Determine symmetry group
        symmetry_group = determine_symmetry_group(
            has_inversion, 
            mirror_planes, 
            rotation_symmetry,
            len(atoms)
        )
        results['data']['symmetry_group'] = symmetry_group
        
        return results
        
    except Exception as e:
        return {
            'status': 'error',
            'message': f'Error processing data: {str(e)}'
        }

def check_inversion_symmetry(atoms, tolerance=1e-2):
    """Check if structure has inversion symmetry."""
    for atom in atoms:
        inverted = -atom
        # Check if inverted position exists
        distances = np.linalg.norm(atoms - inverted, axis=1)
        if not np.any(distances < tolerance):
            return False
    return True

def check_mirror_planes(atoms, tolerance=1e-2):
    """Check for mirror planes (xy, xz, yz)."""
    planes = []
    plane_names = ['xy', 'xz', 'yz']
    
    for i, plane in enumerate(plane_names):
        if check_single_mirror_plane(atoms, i, tolerance):
            planes.append(plane)
    
    return planes

def check_single_mirror_plane(atoms, axis, tolerance=1e-2):
    """Check for mirror symmetry in a specific plane."""
    for atom in atoms:
        mirrored = atom.copy()
        mirrored[axis] = -mirrored[axis]
        # Check if mirrored position exists
        distances = np.linalg.norm(atoms - mirrored, axis=1)
        if not np.any(distances < tolerance):
            return False
    return True

def check_rotation_symmetry(atoms, tolerance=1e-2):
    """Check for rotational symmetry (2-fold, 3-fold, 4-fold, 6-fold)."""
    rotation_orders = []
    
    for n in [2, 3, 4, 6]:
        angle = 2 * np.pi / n
        if check_rotation_n_fold(atoms, angle, tolerance):
            rotation_orders.append(n)
    
    return rotation_orders

def check_rotation_n_fold(atoms, angle, tolerance=1e-2):
    """Check for n-fold rotation symmetry around z-axis."""
    cos_a, sin_a = np.cos(angle), np.sin(angle)
    rotation_matrix = np.array([
        [cos_a, -sin_a, 0],
        [sin_a, cos_a, 0],
        [0, 0, 1]
    ])
    
    for atom in atoms:
        rotated = rotation_matrix @ atom
        # Check if rotated position exists
        distances = np.linalg.norm(atoms - rotated, axis=1)
        if not np.any(distances < tolerance):
            return False
    return True

def determine_symmetry_group(has_inversion, mirror_planes, rotation_symmetry, num_atoms):
    """Determine the point group based on symmetry elements."""
    
    if num_atoms == 1:
        return "K_h (spherical symmetry)"
    
    if len(rotation_symmetry) == 0 and len(mirror_planes) == 0 and not has_inversion:
        return "C_1 (no symmetry)"
    
    if len(rotation_symmetry) == 0 and len(mirror_planes) == 1 and not has_inversion:
        return "C_s (single mirror plane)"
    
    if has_inversion and len(mirror_planes) == 0 and len(rotation_symmetry) == 0:
        return "C_i (inversion center)"
    
    if 6 in rotation_symmetry:
        if has_inversion and len(mirror_planes) >= 3:
            return "D_6h (hexagonal)"
        elif has_inversion:
            return "D_6 (hexagonal rotation)"
        return "C_6"
    
    if 4 in rotation_symmetry:
        if has_inversion and len(mirror_planes) >= 2:
            return "D_4h (tetragonal)"
        elif has_inversion:
            return "D_4 (tetragonal rotation)"
        return "C_4"
    
    if 3 in rotation_symmetry:
        if has_inversion and len(mirror_planes) >= 3:
            return "D_3h (trigonal)"
        elif has_inversion:
            return "D_3 (trigonal rotation)"
        return "C_3"
    
    if 2 in rotation_symmetry:
        if has_inversion and len(mirror_planes) >= 2:
            return "D_2h (orthorhombic)"
        elif len(mirror_planes) >= 2:
            return "C_2v (2-fold with mirrors)"
        elif has_inversion:
            return "D_2 (2-fold rotation)"
        return "C_2"
    
    return "Unknown symmetry group"

def format_results(results):
    """Format results for display."""
    if results['status'] == 'error':
        return f"ERROR: {results['message']}"
    
    output = []
    output.append("=" * 60)
    output.append("SYMMETRY GROUP CLASSIFICATION RESULTS")
    output.append("=" * 60)
    output.append("")
    
    data = results['data']
    output.append(f"Number of atoms: {data['num_atoms']}")
    output.append("")
    
    output.append("Center of mass:")
    output.append(f"  {data['center_of_mass']}")
    output.append("")
    
    output.append(f"Inversion symmetry: {'Yes' if data['has_inversion_symmetry'] else 'No'}")
    output.append("")
    
    if data['mirror_planes']:
        output.append(f"Mirror planes: {', '.join(data['mirror_planes'])}")
    else:
        output.append("Mirror planes: None")
    output.append("")
    
    if data['rotation_symmetry']:
        output.append(f"Rotational symmetry: {'-fold, '.join(map(str, data['rotation_symmetry']))}-fold")
    else:
        output.append("Rotational symmetry: None")
    output.append("")
    
    output.append("=" * 60)
    output.append(f"SYMMETRY GROUP: {data['symmetry_group']}")
    output.append("=" * 60)
    
    return "\\n".join(output)
`);
                
                statusElement.className = 'status ready';
                statusElement.textContent = '‚úÖ Python environment ready!';
                
                fileInput.disabled = false;
                uploadBtn.disabled = false;
                
                logToConsole('Ready to process files!', 'success');
                logToConsole('Upload a file with atomic coordinates to begin analysis.', 'info');
                
            } catch (error) {
                logToConsole(`Error initializing Python: ${error.message}`, 'error');
                statusElement.textContent = '‚ùå Failed to initialize Python environment';
            }
        }

        // Handle file selection
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                fileName = file.name;
                const reader = new FileReader();
                reader.onload = (event) => {
                    fileContent = event.target.result;
                    fileInfo.style.display = 'block';
                    fileInfo.textContent = `üìÑ Selected file: ${fileName} (${(file.size / 1024).toFixed(2)} KB)`;
                    logToConsole(`File loaded: ${fileName}`, 'info');
                };
                reader.readAsText(file);
            }
        });

        // Handle file processing
        uploadBtn.addEventListener('click', async () => {
            if (!fileContent) {
                logToConsole('Please select a file first!', 'warning');
                return;
            }

            try {
                logToConsole('', 'log');
                logToConsole('=' .repeat(60), 'log');
                logToConsole(`Processing file: ${fileName}`, 'info');
                logToConsole('=' .repeat(60), 'log');
                
                uploadBtn.disabled = true;
                uploadBtn.textContent = 'Processing...';

                // Run the Python classification
                const result = await pyodide.runPythonAsync(`
results = classify_symmetry_group('''${fileContent.replace(/'/g, "\\'")}''')
format_results(results)
`);

                logToConsole(result, 'log');
                logToConsole('', 'log');
                logToConsole('Analysis complete!', 'success');
                
            } catch (error) {
                logToConsole(`Error processing file: ${error.message}`, 'error');
            } finally {
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Process File';
            }
        });

        // Clear console
        clearBtn.addEventListener('click', clearConsole);

        // Initialize on page load
        window.addEventListener('load', initPyodide);
    </script>
</body>
</html>
